# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: 3

# The following are named snippets to avoid duplication.
require_jq: &require_jq
  sh: 'command -v jq'
  msg: 'You must install jq.'
require_parallel: &require_parallel
  sh: 'command -v parallel'
  msg: 'You must install GNU Parallel.'
require_v28: &require_v28
  sh: 'test {{.TASK_MINOR_VERSION}} -ge 28'
  msg: 'Please upgrade Task to v3.28.0 or greater.'

dotenv:
  - .env.local
  - .local.env
  - .env

vars:
  TASK_MINOR_VERSION:
    sh: echo "{{.TASK_VERSION}}" | awk -F'.' '{print $2}'

tasks:
  default:
    desc: 'Runs all the subtask in order. See "task --summary" for usage.'
    summary: |
      This command will build docker images for all the services listed in the
      services directory.

      You need to have Task v3.28.0 or greater, GNU parallel, and jq.

      Optionally, you may run just a subset of those by passing the subdirs you
      would like to build after a double dash. For example, the following would
      build just the php-nginx and php-apache images:

      $ task -- php-nginx php-apache
    preconditions:
      - *require_parallel
      - *require_v28
      - *require_jq
    cmds:
      - task: generate
      - task: bakefile
      - task: bake
      - task: build
      - task: push
      - task: push-manifests

  generate:
    desc: '[subtask] Generate Dockerfiles for the services.'
    vars:
      TARGETS:
        # If CLI_ARGS has items in it, those are our targets. Otherwise, use all
        # the subdirectories in /services.
        sh: test -n '{{.CLI_ARGS}}' && echo '{{.CLI_ARGS}}' || echo $(find services -type d -maxdepth 1 -mindepth 1 -exec basename {} \;)
    cmd: 'parallel SERVICEDIR={} task generate-one ::: {{.TARGETS}}'

  generate-one:
    vars:
      NAME:
        sh: |
          test -f services/{{.SERVICEDIR}}/manifest && source services/{{.SERVICEDIR}}/manifest
          (test -n "$NAME" && echo "$NAME") || (test -n "$SERVICE" && echo "$SERVICE") || echo "{{.SERVICEDIR}}"
    preconditions:
      - sh: 'test -n "{{.SERVICEDIR}}"'
        msg: 'Specify the subdirectory name of the service with a SERVICEDIR environment variable.'
      - sh: 'test -d "services/{{.SERVICEDIR}}"'
        msg: 'services/{{.SERVICEDIR}} does not exist.'
    sources:
      - services/{{.SERVICEDIR}}/**
      - templates/Dockerfile.*.template
    generates:
      - images/{{.NAME}}/*/*
      - images/{{.NAME}}/MANIFEST_LIST
    cmds:
      - scripts/generate.sh {{.SERVICEDIR}}

  bakefile:
    desc: '[subtask] Create a bakefile based on the available Dockerfiles.'
    preconditions:
      - sh: 'test -d images'
        msg: 'Generate some Dockerfiles first using task generate.'
      - *require_jq
    cmds:
      - scripts/bakefile.sh
      - defer: rm -f newbake.json

  create-builder:
    desc: '[subtask] Create the Docker buildx builder.'
    deps:
      - buildkitd.toml
    status:
      # Exits zero (up to date) if there is already a builder.
      - docker buildx ls | grep -q '^{{.BUILDX_BUILDER}}'
    cmds:
      - docker buildx create
          --name "{{.BUILDX_BUILDER}}"
          --config buildkitd.toml

  buildkitd.toml:
    internal: true
    status:
      - grep -q "max-parallelism = ${BUILDX_MAX_PARALLELISM}\$" buildkitd.toml
    sources:
      - templates/buildkitd.template.toml
    generates:
      - ./buildkitd.toml
    cmds:
      - envsubst < templates/buildkitd.template.toml > buildkitd.toml

  bake:
    desc: '[subtask] Runs docker buildx bake using the bake.json generated by bakefile.'
    preconditions:
      - *require_jq
    status:
      # Exits zero (up to date) if there are no targets.
      - test $(jq '.target | length' bake.json) -eq 0
    deps:
      - bakefile
      - create-builder
    cmds:
      - docker buildx bake --builder '{{.BUILDX_BUILDER}}' --file ./bake.json

  build:
    desc: '[subtask] Build any docker image tarballs generated from bake for Tugboat usage.'
    preconditions:
      - *require_parallel
    status:
      # Exits zero (up to date) if there are no tarballs.
      - test -z "{{.TARBALLS}}"
    vars:
      TARBALLS:
        # We loop over any image.tar files to be sure we only build images that
        # still need to be built.
        sh: find images/*/* -maxdepth 1 -name image.tar
    cmds:
      - 'parallel --jobs {{.PARALLEL_JOBS}} --retries 2 --tag scripts/build.sh ::: $(echo "{{.TARBALLS}}")'

  test:
    desc: 'Test all images and tags of a single service.'
    vars:
      SERVICE: '{{.CLI_ARGS}}'
    preconditions:
      - sh: test -n "{{.CLI_ARGS}}"
        msg: Specify the service to test after a double dash, e.g. 'task test -- example'.
      - sh: echo "{{.CLI_ARGS}}" | grep -vq '\s'
        msg: You may only test one service at a time.
      - sh: ! test -d services/{{.CLI_ARGS}}
        msg: The directory services/{{.CLI_ARGS}} does not exist.
    cmd: scripts/test.sh {{.SERVICE}}

  push:
    desc: '[subtask] Push all images to docker.io. Be sure PUSH is set to true in your .env.local.'
    preconditions:
      - *require_v28
    status:
      # Exits zero (up to date) if there are no images OR PUSH is falsey.
      - test -z "{{.IMAGES}}" || (test "$PUSH" != "true" && test "$PUSH" != "1")
    vars:
      IMAGES:
        sh: find images/* -type d -name built -maxdepth 1 -exec sh -c 'basename $(dirname {})' \;
    cmds:
      - for: { var: IMAGES }
        task: push-one
        vars:
          IMAGE: '{{.ITEM}}'

  push-one:
    internal: true
    preconditions:
      - sh: test -n "{{.IMAGE}}"
        msg: Specify an image with the environment variable IMAGE.
      - sh: test "$PUSH" = "true" || test "$PUSH" = "1"
        msg: PUSH is disabled.
    cmd: scripts/push.sh {{.IMAGE}}

  push-manifests:
    desc: '[subtask] Push all manifest lists to docker.io. Be sure PUSH is set to true in your .env.local.'
    preconditions:
      - *require_v28
    status:
      # Exits zero if PUSH is falsey or there are no manifest lists.
      - test "$PUSH" != "true" && test "$PUSH" != "1" || test -z "{{.MANIFEST_LISTS}}"
    vars:
      MANIFEST_LISTS:
        sh: find images/* -maxdepth 1 -name MANIFEST_LIST
    cmds:
      - for: { var: MANIFEST_LISTS }
        task: push-manifest
        vars:
          MANIFEST_LIST: '{{.ITEM}}'

  push-manifest:
    internal: true
    preconditions:
      - sh: test -n "{{.MANIFEST_LIST}}"
        msg: Specify the path to the manifest list you would like to create with MANIFEST_LIST variable.
      - sh: test -s "{{.MANIFEST_LIST}}"
        msg: The manifest list {{.MANIFEST_LIST}} does not exist or is empty.
    status:
      - test "$PUSH" != "true" && test "$PUSH" != "1"
    cmds:
      - scripts/manifest.sh {{.MANIFEST_LIST}}

  prepare-docs:
    desc: '[subtask] Prepares the images directory for publishing at https://github.com/TugboatQA/dockerfiles.'
    preconditions:
      - *require_v28
    vars:
      IMAGES:
        sh: echo $(find images -type d -maxdepth 1 -mindepth 1 -exec basename {} \;)
    cmds:
      - for: { var: IMAGES }
        task: create-tags-md
        vars:
          IMAGE: '{{.ITEM}}'

  create-tags-md:
    internal: true
    sources:
      - images/{{.IMAGE}}/*/TAGS
    generates:
      - images/{{.IMAGE}}/TAGS.md
    cmd: scripts/tags.sh "{{.IMAGE}}" > "images/{{.IMAGE}}/TAGS.md"

  clean:
    desc: 'Removes all generated files and docker images.'
    prompt: This will remove any generated files and delete all docker images in
            the {{.NAMESPACE}}/* namespace. Do you want to continue?
    deps:
      - rm-files
      - rm-images

  clean-all:
    desc: 'Removes the buildkit builder, all generated files, and all docker images.'
    deps:
      - rm-builder
      - rm-files
      - rm-images
    prompt: This will remove the buildkit builder, all generated files, and
      delete all docker images in the {{.NAMESPACE}}/* namespace. Do you
      want to continue?

  rm-builder:
    internal: true
    status:
      - if docker buildx ls | grep -q '^{{.BUILDX_BUILDER}}\s'; then exit 1; fi
    cmd: docker buildx rm -f '{{.BUILDX_BUILDER}}'
  rm-files:
    internal: true
    cmds:
      - rm -f bake.json buildkitd.toml
      - rm -Rf images
  rm-images:
    internal: true
    status:
      - test -z "{{.IMAGES}}"
    vars:
      IMAGES:
        sh: docker images ls --filter=reference="{{.NAMESPACE}}/*" -q | sort | uniq
    cmd: docker rmi --force $(echo "{{.IMAGES}}") || true

